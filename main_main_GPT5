from __future__ import division
import time, math as m, numpy as np, array as arr, timeit
from sshkeyboard import listen_keyboard
import Adafruit_PCA9685

# ===================== CONFIG =====================
# Servo PWM
SERVO_MIN = 100
SERVO_MAX = 600
PWM_FREQ  = 60

# Cơ học
l1 = 46.4   # mm
l2 = 114.2  # mm
l3 = 110.0  # mm

RH = -140   # Robot height (z)
SH = 45     # Swing height

# Định danh
Front, Rear = 30, 31            # side flags
front_left, front_right = 0, 3
rear_left,  rear_right  = 6, 9

# Offsets [t1, t2, t3] (deg)
FL_off = arr.array('i', [92, 62, 12])     # Front Left
RL_off = arr.array('i', [85, 93, 24])     # Rear  Left
FR_off = arr.array('i', [82, 83, 183])    # Front Right
RR_off = arr.array('i', [92, 95, 180])    # Rear  Right

# Vị trí chân (x, y, z)
posFL = [0.0, 0.0, 0.0]
posFR = [0.0, 0.0, 0.0]
posRL = [0.0, 0.0, 0.0]
posRR = [0.0, 0.0, 0.0]

# Kích thước robot (đặt theo code của anh)
A = 269.5
B = 80.3
g_FL = np.array([[A/2],[ B/2],[0]])
g_FR = np.array([[A/2],[-B/2],[0]])
g_RL = np.array([[-A/2],[ B/2],[0]])
g_RR = np.array([[-A/2],[-B/2],[0]])

# ===================== UTILS =====================
def clamp(v, lo, hi): 
    return lo if v < lo else (hi if v > hi else v)

def angle2pulse(angle_deg):
    pulse = int(100 + 500 * (angle_deg / 180.0))
    return clamp(pulse, SERVO_MIN, SERVO_MAX)

def safe_acos(x):
    return m.acos(clamp(x, -1.0, 1.0))

def safe_asin(x):
    return m.asin(clamp(x, -1.0, 1.0))

# ===================== SERVO BUS =====================
class ServoBus:
    """
    Map 1 chân (leg) => 3 kênh PCA9685. 
    Thay cho hàm không tồn tại pwm.set_pwm_servo(...)
    """
    def __init__(self, freq=PWM_FREQ):
        self.pca = Adafruit_PCA9685.PCA9685()
        self.pca.set_pwm_freq(freq)
        # Sửa map theo đấu dây thực tế
        self.LEG_CHANNELS = {
            'FL': (0, 1, 2),
            'FR': (3, 4, 5),
            'RL': (6, 7, 8),
            'RR': (9,10,11),
        }

    def set_triplet(self, key, t1, t2, t3):
        ch1, ch2, ch3 = self.LEG_CHANNELS[key]
        self.pca.set_pwm(ch1, 0, angle2pulse(t1))
        self.pca.set_pwm(ch2, 0, angle2pulse(t2))
        self.pca.set_pwm(ch3, 0, angle2pulse(t3))

pwm = ServoBus()

# ===================== IMU (mock) =====================
class IMU:
    """Thay bằng driver MPU6050 thật của anh. Hàm get_RP() trả (roll,pitch) deg."""
    def __init__(self):
        self.ok = False  # set True nếu có driver thật

    def get_RP(self):
        if self.ok:
            # TODO: đọc từ MPU thật
            return 0.0, 0.0
        return 0.0, 0.0

imu = IMU()

# ===================== IK & SET LEG =====================
def setLegAngles(LegAdress, Theta1, Theta2, Theta3):
    if LegAdress == front_left:
        t1 = 180 - (Theta1 + FL_off[0])
        t2 = Theta2 + FL_off[1]
        t3 = Theta3 + FL_off[2]
        pwm.set_triplet('FL', t1, t2, t3)

    elif LegAdress == front_right:
        t1 = 180 - (Theta1 + FR_off[0])
        t2 = Theta2 + FR_off[1]
        t3 = Theta3 + FR_off[2]
        pwm.set_triplet('FR', t1, t2, t3)

    elif LegAdress == rear_left:
        t1 = Theta1 + RL_off[0]
        t2 = Theta2 + RL_off[1]
        t3 = Theta3 + RL_off[2]
        pwm.set_triplet('RL', t1, t2, t3)

    elif LegAdress == rear_right:
        t1 = Theta1 + RR_off[0]
        t2 = Theta2 + RR_off[1]
        t3 = Theta3 + RR_off[2]
        pwm.set_triplet('RR', t1, t2, t3)
    else:
        raise ValueError("Wrong Leg Address")

def Check_work_space(x,y,z):
    k1 = x**2 + y**2 + z**2
    k2 = y**2 + z**2
    if (k2 < (l1**2 + (l2 - l3)**2)) or (k1 > (l1**2 + (l2 + l3)**2)):
        raise ValueError("Out of workspace: (%.2f, %.2f, %.2f)" % (x, y, z))

def LEFT_Inverse_Kinematics(leg, x, y, z):
    global posFL, posRL
    Check_work_space(x,y,z)
    r = m.sqrt(y*y + z*z)
    if r < 1e-6: r = 1e-6
    alpha = safe_acos(y / r)
    r2 = m.sqrt(z*z + y*y)  # = r
    t1 = -(safe_acos(clamp(l1 / r2, -1, 1)) - alpha)
    c1, s1 = m.cos(t1), m.sin(t1)

    A = -x
    if abs(s1) > 1e-6:
        B = (l1*c1 - y)/s1
    else:
        B = (-l1*s1 - z)/max(c1, 1e-6)

    c3 = (A*A + B*B - l2*l2 - l3*l3) / (2*l2*l3)
    c3 = clamp(c3, -1.0, 1.0)
    s3 = m.sqrt(max(0.0, 1 - c3*c3))
    t3 = m.atan2(s3, c3)

    s2 = (A * (l2 + l3*c3) + B * l3*s3)
    c2 = (B * (l2 + l3*c3) - A * l3*s3)
    t2 = m.atan2(s2, c2)

    t1d, t2d, t3d = map(m.degrees, (t1, t2, t3))
    if leg == Rear:
        setLegAngles(rear_left, t1d, t2d, t3d)
        posRL = [x, y, z]
    else:
        setLegAngles(front_left, t1d, t2d, t3d)
        posFL = [x, y, z]

def RIGHT_Inverse_Kinematics(leg, x, y, z):
    global posFR, posRR
    Check_work_space(x,y,z)
    r = m.sqrt(y*y + z*z)
    if r < 1e-6: r = 1e-6
    alpha = safe_asin(y / r)
    r2 = m.sqrt(z*z + y*y)  # = r
    t1 = -(safe_asin(clamp(l1 / r2, -1, 1)) + alpha)
    c1, s1 = m.cos(t1), m.sin(t1)

    A = -x
    if abs(s1) > 1e-6:
        B = (-l1*c1 - y)/s1
    else:
        B = (l1*s1 - z)/max(c1, 1e-6)

    c3 = (A*A + B*B - l2*l2 - l3*l3) / (2*l2*l3)
    c3 = clamp(c3, -1.0, 1.0)
    s3 = m.sqrt(max(0.0, 1 - c3*c3))
    t3 = -m.atan2(s3, c3)

    s2 = (A * (l2 + l3*c3) + B * l3*s3)
    c2 = (B * (l2 + l3*c3) - A * l3*s3)
    t2 = -m.atan2(s2, c2)

    t1d, t2d, t3d = map(m.degrees, (t1, t2, t3))
    if leg == Rear:
        setLegAngles(rear_right, t1d, t2d, t3d)
        posRR = [x, y, z]
    else:
        setLegAngles(front_right, t1d, t2d, t3d)
        posFR = [x, y, z]

# ===================== PID có trạng thái =====================
class PID:
    def __init__(self, kp=0.125, ki=0.01, kd=0.001, dt=0.02, out_lim=20):
        self.kp, self.ki, self.kd = kp, ki, kd
        self.dt = dt
        self.out_lim = out_lim
        self.err_p = 0.0
        self.iterm = 0.0
    def compute(self, setpoint, measured):
        err = setpoint - measured
        self.iterm += self.ki * err * self.dt
        dterm = self.kd * (err - self.err_p) / self.dt
        self.err_p = err
        out = self.kp*err + self.iterm + dterm
        return clamp(out, -self.out_lim, self.out_lim)

pid_pitch = PID()
pid_roll  = PID()

def self_balancing_pitch(pitch_angle_deg):
    global posFL, posFR, posRL, posRR
    x = 269.5  # distance FL↔RL projection
    corr = m.tan(m.radians(pid_pitch.compute(0, pitch_angle_deg)))
    dz = (x/2.0) * corr
    posFL[2] += dz; posFR[2] += dz
    RIGHT_Inverse_Kinematics(Front, 0, -l1, posFR[2])
    LEFT_Inverse_Kinematics (Front, 0,  l1, posFL[2])
    posRL[2] -= dz; posRR[2] -= dz
    RIGHT_Inverse_Kinematics(Rear,  0, -l1, posRR[2])
    LEFT_Inverse_Kinematics (Rear,  0,  l1, posRL[2])

def self_balancing_roll(roll_angle_deg):
    global posFL, posFR, posRL, posRR
    x = 80.3 + 2*l1
    corr = m.tan(m.radians(pid_roll.compute(0, roll_angle_deg)))
    dz = (x/2.0) * corr
    posFR[2] += dz; posRR[2] += dz
    RIGHT_Inverse_Kinematics(Front, 0, -l1, posFR[2])
    RIGHT_Inverse_Kinematics(Rear,  0, -l1, posRR[2])
    posFL[2] -= dz; posRL[2] -= dz
    LEFT_Inverse_Kinematics (Front, 0,  l1, posFL[2])
    LEFT_Inverse_Kinematics (Rear,  0,  l1, posRL[2])

# ===================== POSE & GAIT =====================
def initial_position():
    LEFT_Inverse_Kinematics (Front, 0,  l1, RH)
    RIGHT_Inverse_Kinematics(Front, 0, -l1, RH)
    LEFT_Inverse_Kinematics (Rear,  0,  l1, RH)
    RIGHT_Inverse_Kinematics(Rear,  0, -l1, RH)
    time.sleep(0.5)
    print("Ready")

def all_Move(dx, dy, dz, delay_s):
    # snapshot
    pFR = posFR[:]; pRR = posRR[:]; pFL = posFL[:]; pRL = posRL[:]
    for t in np.arange(0.25, 1.005, 0.25):
        RIGHT_Inverse_Kinematics(Front, pFR[0] - dx*t, pFR[1] + dy*t, pFR[2] - dz*t)
        RIGHT_Inverse_Kinematics(Rear,  pRR[0] - dx*t, pRR[1] + dy*t, pRR[2] - dz*t)
        LEFT_Inverse_Kinematics (Rear,  pRL[0] - dx*t, pRL[1] + dy*t, pRL[2] - dz*t)
        LEFT_Inverse_Kinematics (Front, pFL[0] - dx*t, pFL[1] + dy*t, pFL[2] - dz*t)
        time.sleep(delay_s)

def all_To_initial(delay_s):
    pFR = posFR[:]; pRR = posRR[:]; pFL = posFL[:]; pRL = posRL[:]
    for t in np.arange(0.25, 1.005, 0.25):
        RIGHT_Inverse_Kinematics(Front, pFR[0] - pFR[0]*t, pFR[1] - (pFR[1]+l1)*t, pFR[2] - (pFR[2]-RH)*t)
        RIGHT_Inverse_Kinematics(Rear,  pRR[0] - pRR[0]*t, pRR[1] - (pRR[1]+l1)*t, pRR[2] - (pRR[2]-RH)*t)
        LEFT_Inverse_Kinematics (Rear,  pRL[0] - pRL[0]*t, pRL[1] - (pRL[1]-l1)*t, pRL[2] - (pRL[2]-RH)*t)
        LEFT_Inverse_Kinematics (Front, pFL[0] - pFL[0]*t, pFL[1] - (pFL[1]-l1)*t, pFL[2] - (pFL[2]-RH)*t)
        time.sleep(delay_s)

def startTrot(SL_x, SL_y, delay_s):
    A_x, A_z = (-25, -10) if SL_x > 0 else (20, -5) if SL_x < 0 else (-7, 0)
    A_y = 10 if SL_y > 0 else (-10 if SL_y < 0 else 0)
    for t in np.arange(0.125,0.505,0.125):
        x = -SL_x*t + A_x; z = RH; y = l1 + SL_y*t + A_y
        LEFT_Inverse_Kinematics (Front, x, y, z)
        z += A_z; y = -l1 + SL_y*t + A_y
        RIGHT_Inverse_Kinematics(Rear,  x, y, z)

        alpha = m.pi*(2*t)
        x = -(SL_x/4)*m.cos(alpha) + A_x + SL_x/4
        z = RH + SH/1.5*m.sin(alpha)
        y = -l1 + (SL_y/4)*m.cos(alpha) + A_y - SL_y/4
        RIGHT_Inverse_Kinematics(Front, x, y, z)
        z += A_z
        y = l1 + (SL_y/4)*m.cos(alpha) + A_y - SL_y/4
        LEFT_Inverse_Kinematics (Rear,  x, y, z)
        time.sleep(delay_s)

def endTrot(SL_x, SL_y, delay_s):
    A_x, A_z = (-25, -10) if SL_x > 0 else (20, -5) if SL_x < 0 else (-7, 0)
    A_y = 10 if SL_y > 0 else (-10 if SL_y < 0 else 0)
    for t in np.arange(0.125,0.505,0.125):
        x = -SL_x*t + A_x + SL_x/2; z = RH; y = -l1 + SL_y*t + A_y - SL_y/2
        RIGHT_Inverse_Kinematics(Front, x, y, z)
        z += A_z; y = l1 + SL_y*t + A_y - SL_y/2
        LEFT_Inverse_Kinematics (Rear,  x, y, z)

        alpha= m.pi*(2*t)
        x = -(SL_x/4)*m.cos(alpha) + A_x - SL_x/4
        z = RH + SH/1.5*m.sin(alpha)
        y = l1 + (SL_y/4)*m.cos(alpha) + A_y + SL_y/4
        LEFT_Inverse_Kinematics (Front, x, y, z)
        z += A_z
        y = -l1 + (SL_y/4)*m.cos(alpha) + A_y + SL_y/4
        RIGHT_Inverse_Kinematics(Rear,  x, y, z)
        time.sleep(delay_s)

def Trot_gait(SL_x, SL_y, delay_s):
    start = timeit.default_timer()
    A_x, A_z = (-25, -10) if SL_x > 0 else (20, -5) if SL_x < 0 else (-7, 0)
    A_y = 10 if SL_y > 0 else (-10 if SL_y < 0 else 0)

    for t in np.arange(0,1.005,0.125):
        x = -SL_x*t+(SL_x/2) + A_x
        y = -l1 + SL_y*t-(SL_y/2) + A_y
        z = RH
        RIGHT_Inverse_Kinematics(Front, x, y, z)
        z += A_z; y = l1 + SL_y*t-(SL_y/2) + A_y
        LEFT_Inverse_Kinematics (Rear,  x, y, z)

        alpha= m.pi*(1-t)
        x = (SL_x/2)*m.cos(alpha) + A_x
        y = l1 - (SL_y/2)*m.cos(alpha) + A_y
        z = RH + SH*m.sin(alpha)
        LEFT_Inverse_Kinematics (Front, x, y, z)
        z += A_z; y = -l1 - (SL_y/2)*m.cos(alpha) + A_y
        RIGHT_Inverse_Kinematics(Rear,  x, y, z)
        time.sleep(delay_s)

    for t in np.arange(0,1.005,0.125):
        alpha= m.pi*(1-t)
        x = (SL_x/2)*m.cos(alpha) + A_x
        y = -l1 - (SL_y/2)*m.cos(alpha) + A_y
        z = RH + SH*m.sin(alpha)
        RIGHT_Inverse_Kinematics(Front, x, y, z)
        z += A_z; y = l1 - (SL_y/2)*m.cos(alpha) + A_y
        LEFT_Inverse_Kinematics (Rear,  x, y, z)

        x = -SL_x*t+(SL_x/2) + A_x
        y = l1 + SL_y*t-(SL_y/2) + A_y
        z = RH
        LEFT_Inverse_Kinematics (Front, x, y, z)
        z += A_z; y = -l1 + SL_y*t-(SL_y/2) + A_y
        RIGHT_Inverse_Kinematics(Rear,  x, y, z)
        time.sleep(delay_s)

    stop = timeit.default_timer()
    print("Trot cycle:", stop - start, "s")

def Turn(veer):
    # Giữ đúng giải thuật của anh, chỉ format lại
    for t in np.arange(0,1.005,0.25):
        tt = 1 - t if veer == 0 else t
        alpha = m.pi*tt
        x = (0+17.8)/2 + ((0-17.8)/2)*m.cos(alpha)
        y = (l1+8.6)/2 + ((l1-8.6)/2)*m.cos(alpha)
        z = RH + SH*m.sin(alpha)
        LEFT_Inverse_Kinematics (Front, x,  y,  z)
        RIGHT_Inverse_Kinematics(Rear, -x, -y,  z)
        x2 = -27*(1-tt)
        y2 = -78.3 + (-l1+78.3)*tt
        RIGHT_Inverse_Kinematics(Front, x2, y2, RH)
        LEFT_Inverse_Kinematics (Rear, -x2,-y2, RH)
        time.sleep(0.025)

    for t in np.arange(0,1.005,0.25):
        tt = 1 - t if veer == 0 else t
        alpha= m.pi*tt
        x = (0-27)/2 + (0-(-27)/2)*m.cos(alpha)
        y = (-l1+(-78.3))/2 + ((-l1-(-78.3))/2)*m.cos(alpha)
        z = RH + SH*m.sin(alpha)
        RIGHT_Inverse_Kinematics(Front, x,  y,  z)
        LEFT_Inverse_Kinematics (Rear, -x, -y,  z)
        x2 = -17.8*(1-tt)
        y2 = -8.5 + (-l1+8.5)*tt
        RIGHT_Inverse_Kinematics(Rear,  x2,  y2, RH)
        LEFT_Inverse_Kinematics (Front, -x2, -y2, RH)
        time.sleep(0.025)

# ===================== KEYBOARD CONTROL =====================
# Trạng thái phím (đơn giản)
key_state = {
    'w': False, 's': False, 'a': False, 'd': False,
    '9': False, '0': False, 'p': False,
    '1': False, '2': False, '3': False, '4': False, '5': False, '6': False
}
move_started = False

# RPY mong muốn (để Roll_Pitch_Yaw nếu anh muốn dùng)
Roll_rpy = 0.0
Pitch_rpy = 0.0
Yaw_rpy = 0.0

def on_press(key):
    if key in key_state: key_state[key] = True

def on_release(key):
    if key in key_state: key_state[key] = False

def control_step(dt=0.02):
    """Gọi mỗi chu kỳ; thực thi theo trạng thái phím."""
    global move_started, Roll_rpy, Pitch_rpy, Yaw_rpy

    # IMU balance (nếu có)
    roll, pitch = imu.get_RP()
    self_balancing_pitch(pitch)
    self_balancing_roll(roll)

    # Gait điều hướng
    if key_state['w']:
        if not move_started:
            print("Forward")
            all_Move(25, 0, 0, 0.01)
            startTrot(60, 0, 0.01)
            move_started = True
        else:
            Trot_gait(60, 0, 0.01)

    if key_state['s']:
        if not move_started:
            print("Backward")
            all_Move(-20, 0, 0.01)
            startTrot(-60, 0, 0.01)
            move_started = True
        else:
            Trot_gait(-60, 0, 0.01)

    if key_state['a']:
        if not move_started:
            print("Left")
            all_Move(10, -20, 0, 0.01)
            startTrot(0, -40, 0.02)
            move_started = True
        else:
            Trot_gait(0, -40, 0.01)

    if key_state['d']:
        if not move_started:
            print("Right")
            all_Move(10, 20, 0, 0.01)
            startTrot(0, 40, 0.02)
            move_started = True
        else:
            Trot_gait(0, 40, 0.01)

    if key_state['9']:
        Turn(0)
    if key_state['0']:
        Turn(1)

    if key_state['p']:
        print("Stop")
        time.sleep(0.35)
        all_To_initial(0.01)
        move_started = False

    # RPY điều khiển thủ công (tùy chọn)
    step = 3.0
    if key_state['1']: Roll_rpy  += step
    if key_state['2']: Roll_rpy  -= step
    if key_state['3']: Pitch_rpy += step
    if key_state['4']: Pitch_rpy -= step
    if key_state['5']: Yaw_rpy   += step
    if key_state['6']: Yaw_rpy   -= step
    # Nếu muốn dùng RPY theo hàm Roll_Pitch_Yaw cũ, anh có thể gọi ở đây.
    # Roll_Pitch_Yaw(Roll_rpy, Pitch_rpy, Yaw_rpy)

    time.sleep(dt)

# ===================== MAIN =====================
if __name__ == "__main__":
    initial_position()
    # Lắng nghe bàn phím ở thread riêng; loop chính gọi control_step()
    listen_keyboard(on_press=on_press, on_release=on_release, delay_second_char=0.03, blocking=False)
    try:
        while True:
            control_step(0.02)  # 50Hz
    except KeyboardInterrupt:
        all_To_initial(0.01)
        print("Bye")
